@page "/"
@inject IJSRuntime JSRuntime
@using Time.AnimationConfig;
@using Time.Components;

<div class="clocks-wrapper">
    @for (int j = 0; j < 8; j++)
    {
        <div class="clock-container">
            @for (int i = 1; i < 4; i++)
            {
                <div class="clock">
                    <div class="hour" @ref=HourReference
                        style="transform:rotate(@(controller != null ? controller.Clocks[i + j*3].FirstArm.CurrentState : 0)deg);">
                        <div></div>
                    </div>
                    <div class="minute" @ref=MinuteReference
                        style="transform:rotate(@(controller != null ? controller.Clocks[i + j*3].SecondArm.CurrentState : 0)deg);">
                        <div></div>
                    </div>
                    <span class="ctr"></span>
                </div>
            }
        </div>
    }
</div>

@code {
    private DotNetObjectReference<AnalogClock>? dotNetHelper;
    Controller controller = new Controller();
    List<ElementReference> hourReferences = new List<ElementReference>();
    List<ElementReference> minuteReferences = new List<ElementReference>();
    ElementReference HourReference
    {
        set { hourReferences.Add(value); }
    }

    ElementReference MinuteReference
    {
        set { minuteReferences.Add(value); }
    }
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        await StartAnimation();
    }

    private async Task StartAnimation()
    {
        dotNetHelper = DotNetObjectReference.Create(this);
        // Start the JS animation loop
        await JSRuntime.InvokeVoidAsync("animationLoop.requestAnimationFrame", dotNetHelper);
    }

    public void Dispose()
    {
        dotNetHelper?.Dispose();
    }

    [JSInvokable]
    public async void UpdateFrame(double timeElapsed)
    {
        controller.SetClock(timeElapsed);
        // Trigger the next frame
        await InvokeAsync(StateHasChanged);

        @* for (int i = 1; i <= 24; i++)
            {
                await JSRuntime.InvokeVoidAsync("animationLoop.updateState", hourReferences[i - 1], minuteReferences[i - 1],
                controller.Clocks[i].FirstArm.CurrentState, controller.Clocks[i].SecondArm.CurrentState);
            } *@

        await Task.Yield();
    }

    public class Controller
    {
        private AnimationLifecycleManager animation1;
        private AnimationLifecycleManager mainTimeAnimation;
        private AnimationLifecycleManager animation3;
        private double maxSpeedDegrees = 1;
        public Dictionary<int, Clock> Clocks { get; private set; }
        public Controller()
        {
            Clocks = new Dictionary<int, Clock>();

            for (var i = 0; i < 24; i++)
                Clocks.Add(i + 1, new Clock(i + 1, new ArmConfig
                    {
                        Direction = Direction.Clockwise,
                        MaxSpeedDegrees = maxSpeedDegrees,
                        Acceleration = 1,
                        Deceleration = 1
                    }, new ArmConfig
                    {
                        Direction = Direction.Anticlockwise,
                        MaxSpeedDegrees = maxSpeedDegrees,
                        Acceleration = 1,
                        Deceleration = 1
                    }));

            animation1 = new AnimationLifecycleManager();
            animation1.OnStatusChanged += (AnimationStatus status, double timeElapsed) =>
            {
                switch (status)
                {
                    case AnimationStatus.StartInitAnimation:
                        return AnimationConfigs.StartAnimation2(Clocks, true, timeElapsed);
                    case AnimationStatus.StartAnimation:
                        return AnimationConfigs.StartAnimation2(Clocks, false, timeElapsed);
                    case AnimationStatus.PerformPreAnimationSettings:
                        AnimationConfigs.SetClocksConfigs(Clocks,
        new ArmConfig
                {
                    Direction = Direction.Clockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    Acceleration = 1,
                    Deceleration = 1
                },
        new ArmConfig
                {
                    Direction = Direction.Clockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    Acceleration = 1,
                    Deceleration = 1
                });
                        return false;
                    default: return false;
                }
            };

            mainTimeAnimation = new AnimationLifecycleManager();
            mainTimeAnimation.DelayAnimation.DelayMillisec = 0;
            mainTimeAnimation.OnStatusChanged += (AnimationStatus status, double timeElapsed) =>
            {
                switch (status)
                {
                    case AnimationStatus.StartInitAnimation:
                        return AnimationConfigs.SetNumbers(Clocks);
                    case AnimationStatus.StartAnimation:
                        return AnimationConfigs.SetNumbers(Clocks);
                    case AnimationStatus.PerformPreAnimationSettings:
                        AnimationConfigs.SetClocksConfigs(Clocks,
        new ArmConfig
                {
                    Direction = Direction.Clockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    Acceleration = 1,
                    Deceleration = 1
                },
        new ArmConfig
                {
                    Direction = Direction.Anticlockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    Acceleration = 1,
                    Deceleration = 1
                });
                        return false;
                    default: return false;
                }
            };

            animation3 = new AnimationLifecycleManager();
            animation3.OnStatusChanged += (AnimationStatus status, double timeElapsed) =>
            {
                switch (status)
                {
                    case AnimationStatus.StartInitAnimation:
                        return AnimationConfigs.StartAnimation(Clocks, true);
                    case AnimationStatus.StartAnimation:
                        return AnimationConfigs.StartAnimation(Clocks, false);
                    case AnimationStatus.PerformPreAnimationSettings:
                        AnimationConfigs.SetClocksConfigs(Clocks,
        new ArmConfig
                {
                    Direction = Direction.Clockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    Acceleration = 1,
                    Deceleration = 1
                },
        new ArmConfig
                {
                    Direction = Direction.Anticlockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    Acceleration = 1,
                    Deceleration = 1
                });
                        return false;
                    default: return false;
                }
            };

            mainTimeAnimation.Chain(new List<AnimationLifecycleManager> { animation1, animation3 }, 60000, 60000);

            animation1.OnSettingsCompleted += mainTimeAnimation.OnNextAnimationSettingsCompleted;
            animation3.OnSettingsCompleted += mainTimeAnimation.OnNextAnimationSettingsCompleted;
            mainTimeAnimation.OnSettingsCompleted += animation1.OnNextAnimationSettingsCompleted;
            animation3.OnSettingsCompleted += animation1.OnNextAnimationSettingsCompleted;
            mainTimeAnimation.OnSettingsCompleted += animation3.OnNextAnimationSettingsCompleted;
            animation1.OnSettingsCompleted += animation3.OnNextAnimationSettingsCompleted;
        }

        public void SetClock(double timeElapsed)
        {
            mainTimeAnimation.Start("mainTimeAnimation", timeElapsed);
        }
    }
}
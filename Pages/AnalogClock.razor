@page "/"
@inject IJSRuntime JSRuntime
@using Time.AnimationConfig;
@using Time.AnimationEngine;
@using Time.Utils;
@using Time.Components;

<div class="clocks-wrapper">
    @for (int j = 0; j < 8; j++)
    {
        <div class="clock-container">
            @for (int i = 1; i < 4; i++)
            {
                <div class="clock">
                    <div class="hour" @ref=HourReference
                        style="transform:rotate(@(controller != null ? controller.Clocks[i + j*3].FirstArm.CurrentState : 0)deg);">
                        <div></div>
                    </div>
                    <div class="minute" @ref=MinuteReference
                        style="transform:rotate(@(controller != null ? controller.Clocks[i + j*3].SecondArm.CurrentState : 0)deg);">
                        <div></div>
                    </div>
                    <span class="ctr"></span>
                </div>
            }
        </div>
    }
</div>

@code {
    private DotNetObjectReference<AnalogClock>? dotNetHelper;
    Controller controller = new Controller();
    List<ElementReference> hourReferences = new List<ElementReference>();
    List<ElementReference> minuteReferences = new List<ElementReference>();
    ElementReference HourReference
    {
        set { hourReferences.Add(value); }
    }

    ElementReference MinuteReference
    {
        set { minuteReferences.Add(value); }
    }
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        await StartAnimation();
    }

    private async Task StartAnimation()
    {
        dotNetHelper = DotNetObjectReference.Create(this);
        // Start the JS animation loop
        await JSRuntime.InvokeVoidAsync("animationLoop.requestAnimationFrame", dotNetHelper);
    }

    public void Dispose()
    {
        dotNetHelper?.Dispose();
    }

    [JSInvokable]
    public async void UpdateFrame(double timeElapsed)
    {
        controller.SetClock(timeElapsed);
        // Trigger the next frame
        //await InvokeAsync(StateHasChanged);

        for (int i = 1; i <= 24; i++)
        {
            await JSRuntime.InvokeVoidAsync("animationLoop.updateState", hourReferences[i - 1], minuteReferences[i - 1],
            controller.Clocks[i].FirstArm.CurrentState, controller.Clocks[i].SecondArm.CurrentState);
        }
        await Task.Yield();
    }

    public class Controller
    {
        private AnimationLifecycleManager waveAnimation;
        private AnimationLifecycleManager mainTimeAnimation;
        private AnimationLifecycleManager patternAnimation;
        private int maxSpeedDegrees = 1;
        public Dictionary<int, Clock> Clocks { get; private set; }
        public Controller()
        {
            Clocks = new Dictionary<int, Clock>();

            for (var i = 0; i < 24; i++)
                Clocks.Add(i + 1, new Clock(i + 1));

            waveAnimation = new AnimationLifecycleManager();
            waveAnimation.DelayAnimation.DelayMillisec = 1000;
            waveAnimation.OnStatusChanged += (AnimationStatus status, double timeElapsed) =>
            {
                switch (status)
                {
                    case AnimationStatus.StartInitAnimation:
                        return AnimationConfigs.SetNextWaveAnimationStatus(Clocks, timeElapsed, true);
                    case AnimationStatus.StartAnimation:
                        return AnimationConfigs.SetNextWaveAnimationStatus(Clocks, timeElapsed, false);
                    case AnimationStatus.PerformPreAnimationSettings:
                        AnimationConfigs.SetClocksConfigs(Clocks,
        new ArmConfig
                {
                    Direction = Direction.Clockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    EasingFunction = EasingFunctions.OutSine
                },
        new ArmConfig
                {
                    Direction = Direction.Clockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    EasingFunction = EasingFunctions.OutSine
                }, 60);
                        return false;
                    default: return false;
                }
            };

            mainTimeAnimation = new AnimationLifecycleManager();
            mainTimeAnimation.OnStatusChanged += (AnimationStatus status, double timeElapsedMillisec) =>
            {
                switch (status)
                {
                    case AnimationStatus.StartInitAnimation:
                        return AnimationConfigs.SetNextNumbersAnimationStatus(Clocks, timeElapsedMillisec);
                    case AnimationStatus.StartAnimation:
                        return AnimationConfigs.SetNextNumbersAnimationStatus(Clocks, timeElapsedMillisec);
                    case AnimationStatus.PerformPreAnimationSettings:
                        AnimationConfigs.SetClocksConfigs(Clocks,
        new ArmConfig
                {
                    Direction = Direction.Clockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    EasingFunction = EasingFunctions.Linear
                },
        new ArmConfig
                {
                    Direction = Direction.Anticlockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    EasingFunction = EasingFunctions.Linear
                }, 0);
                        return false;
                    default: return false;
                }
            };

            patternAnimation = new AnimationLifecycleManager();
            patternAnimation.DelayAnimation.DelayMillisec = 1000;
            patternAnimation.OnStatusChanged += (AnimationStatus status, double timeElapsed) =>
            {
                switch (status)
                {
                    case AnimationStatus.StartInitAnimation:
                        return AnimationConfigs.SetNextPatternAnimationStatus(Clocks, timeElapsed, true);
                    case AnimationStatus.StartAnimation:
                        return AnimationConfigs.SetNextPatternAnimationStatus(Clocks, timeElapsed, false);
                    case AnimationStatus.PerformPreAnimationSettings:
                        AnimationConfigs.SetClocksConfigs(Clocks,
        new ArmConfig
                {
                    Direction = Direction.Clockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    EasingFunction = EasingFunctions.Linear
                },
        new ArmConfig
                {
                    Direction = Direction.Anticlockwise,
                    MaxSpeedDegrees = maxSpeedDegrees,
                    EasingFunction = EasingFunctions.Linear
                }, 0);
                        return false;
                    default: return false;
                }
            };

            mainTimeAnimation.Chain(new List<AnimationLifecycleManager> { waveAnimation, patternAnimation }, 60000, 60000);

            waveAnimation.OnSettingsCompleted += mainTimeAnimation.OnNextAnimationSettingsCompleted;
            patternAnimation.OnSettingsCompleted += mainTimeAnimation.OnNextAnimationSettingsCompleted;
            mainTimeAnimation.OnSettingsCompleted += waveAnimation.OnNextAnimationSettingsCompleted;
            patternAnimation.OnSettingsCompleted += waveAnimation.OnNextAnimationSettingsCompleted;
            mainTimeAnimation.OnSettingsCompleted += patternAnimation.OnNextAnimationSettingsCompleted;
            waveAnimation.OnSettingsCompleted += patternAnimation.OnNextAnimationSettingsCompleted;
        }

        public void SetClock(double timeElapsed)
        {
            mainTimeAnimation.Start("mainTimeAnimation", timeElapsed);
        }
    }
}
@page "/"
@inject IJSRuntime JSRuntime
@using Time.AnimationConfig;
@using Time.AnimationEngine;
@using Time.Components;

<div class="clocks-wrapper">
    @for (int j = 0; j < 8; j++)
    {
        <div class="clock-container">
            @for (int i = 1; i < 4; i++)
            {
                <div class="clock">
                    <div class="hour" @ref=HourReference>
                        <div></div>
                    </div>
                    <div class="minute" @ref=MinuteReference>
                        <div></div>
                    </div>
                    <span class="ctr"></span>
                </div>
            }
        </div>
    }
</div>

@code {
    Controller? controller;
    List<ElementReference> hourReferences = new List<ElementReference>();
    List<ElementReference> minuteReferences = new List<ElementReference>();
    ElementReference HourReference
    {
        set { hourReferences.Add(value); }
    }

    ElementReference MinuteReference
    {
        set { minuteReferences.Add(value); }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            controller = new Controller(JSRuntime, hourReferences, minuteReferences);
            controller.SetClock();
        }
    }
    public class Controller
    {
        //private PatternAnimationManager animationManager;
        private ChainedAnimationsManager chainedAnimationsManager;
        public Dictionary<int, Clock> Clocks { get; private set; }
        public Controller(IJSRuntime JSRuntime, List<ElementReference> hourReferences, List<ElementReference> minuteReferences)
        {
            Clocks = new Dictionary<int, Clock>();

            for (var i = 0; i < 24; i++)
                Clocks.Add(i + 1, new Clock(i + 1));

            var wavePatternAnimationManager = new PatternAnimationManager(JSRuntime, Clocks, hourReferences, minuteReferences,
            (Dictionary<int, Clock> clocks) =>
            {
                AnimationConfigs.SetNextWaveAnimationStatus(clocks);
            }, Direction.Anticlockwise, Direction.Anticlockwise, false, true);

            var patternAnimationManager = new PatternAnimationManager(JSRuntime, Clocks, hourReferences, minuteReferences,
            (Dictionary<int, Clock> clocks) =>
            {
                AnimationConfigs.SetNextPatternAnimationStatus(clocks);
            }, Direction.Anticlockwise, Direction.Clockwise, true, false);

            var timeAnimationManager = new TimeAnimationManager(JSRuntime, Clocks, hourReferences, minuteReferences, false, true);

            var anticlockwiseInfiniteAnimationManager = new InfiniteAnimationManager(JSRuntime, Clocks, hourReferences,
            minuteReferences, Direction.Anticlockwise, Direction.Anticlockwise, true);

            var oppositeDirectionsInfiniteAnimationManager = new InfiniteAnimationManager(JSRuntime, Clocks, hourReferences,
            minuteReferences, Direction.Anticlockwise, Direction.Clockwise, false);

            var oppositeDirectionsStaggeredDelayInfiniteAnimationManager = new InfiniteAnimationManager(JSRuntime, Clocks,
            hourReferences,
            minuteReferences, Direction.Anticlockwise, Direction.Clockwise, true);

            chainedAnimationsManager = new ChainedAnimationsManager(new List<(IAnimationManager, int)> { (timeAnimationManager,
20000),(wavePatternAnimationManager, 9000), (anticlockwiseInfiniteAnimationManager, 20000), (timeAnimationManager,
20000), (wavePatternAnimationManager, 9000), (oppositeDirectionsStaggeredDelayInfiniteAnimationManager, 20000) });
        }

        public void SetClock()
        {
            chainedAnimationsManager.Start();
        }
    }
}